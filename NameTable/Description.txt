Проект NameTable

Предназначен для построения таблицы имен. Таблица имен представляет собой множество пар <строка, код>
в котором и строка и код являются уникальными, т.е. однократно использованными. На данном этапе кодирование
производится целыми неотрицательными числами, перечисляющими внесенные идентификаторы. Перечисление сплошное,
без пропусков. Таблица имен представляет также быстрый (Log(N)) перевод из строки в код и обратно, из кода
в строку. 

Таблица имен имеет две фазы работы: фазу заполнения и фазу использования. Фаз заполнения может быть много.
При этом, новые имена (строки) добавляеются к имеющимся. После завершения фазы заполнения (ввода), таблица
находится в фазе использования. Кроме того, фаза заполнения, формирует словарь
Dictionary<string, int> 
В который помещаются пары <строка, код>, только тех строк, которые вводились в течении данной фазы кодирования.
Это нужно для того, чтобы обрабатывая очередную порцию информации, можно было бы сначала перевести имена данной
порции в коды, а потом, выполнить преобразование данных в структурыне построения, использующие коды имеющихся
в порции имен.

Реализация (StringIntCoding)

Имеется основная таблица кодирования, реализованная в виде PaCell, которая содержит последовательность пар
{code: int, name: string}, отсортированную по полю name. В начальный момент таблица содержит 0 элементов. 
Имеется два индекса, т.е. две последовательности длинных целых, представляющих offset'ы элементов в основной 
таблице. Первый индекс отсортирован по полю name, второй - по полю code. 

Имеются методы работы в фазе использования:
int GetCode(string name);
string GetName(int code);
И еще какие-нибудь полезные методы. 

Имеется метод внесения новой порции:
Dictionary<string, int> InsertPortion(IEnumerable<string> portion);

portion - набор вводимых идентификаторов, набор может включать новые, уже введенные и дубли, набор не упорядочен.
Результатом работы метода является словарь содержащий, как минимум, множество пар имя-код по тем идентификаторам,
которые пришли в списке ввода. 
   
Это дорогостоящий по затратам времени метод. Время его выполнения O(N + K) + O(K * Log(K)), где N - предыдущее
количество идентификаторов, K - общее число добавляемых идентификторов. 
В то же время, размер вводимой порции неявно лимитируется возможностью создания результирующего словаря в
оперативной памяти. 

После завершения метода, таблица имен может быть использована в регулярном режиме. 

 
Результаты

Наконец, удалось до конца досчитать массив freebase 
line=1015 млн. 
индексы вычислялись 1549 сек., было 7 слияний. Всего идентификаторов накопилось: 70858321 - чуть больше 70 млн.
Обращает на себя внимание то, что в начале порция вычислялась 50-60 сек., в конце - 90-96. Похоже можно уменьшить 
размер порции.

База данных получилась небольшая - 1381 Мб., индексы - 553.6 Мб. каждый.
 
Весь расчет был выполнен с 15:30 до 19:34, т.е. 4 часа. неплохо. Но это только идентификаторы и без словарей. 

При размере порции в 5 млн. Просчитал 120 млн. триплетов за 13 мин.  

В рамках обработки одной порции, существенными являются времена формирования списка идентификаторов и сортировака-сжимание 
списка. Для размера порции в 5 млн. триплетов, время формирования - 5.5.сек. Время сортировки-сжимания - 18 сек.

Для 10 млн. - 10 и 38 сек. соответственно.

Проведу эксперимент. Постараюсь убрать "лишние" идентификаторы как можно раньше. 

В экспериментальных целях произвел копирование всего набора freebase с дика на диск. Получилось несколько больше 10 мин. 
Так что получается, что ожидать чтения 10 млн. линий менее, чем за 5 сек. сомнительно. Стартую с этой цифры. Она достигается
при просто чтении линий и превращения линий в данные.

При записывании идентификаторов в массив (List), опорное (неуменьшаемое) время стало 9-9.5 сек. Попробую какой-то другой 
способ.

На первой фазе оптимизации, идентификаторы "заталкиваются" в HashSet и это делается довольно быстро. Теперь передадим 
HashSet в процедуру обработки порции. Время обработки порции 7-7.4 сек. В каждой порции "прибывает" 7-8 млн. 
идентификаторов.

Теперь до 100 млн. линий программа "добралась" за 4 мин. Совсем неплохо...

Досчиталось. идентификаторы были обработаны за 1 час и 30 минут. Индексирование, опять за 1558 сек., это где-то 25 мин.

Увеличил размер порции до 20 млн. Вроде, пока скорость обработке не хуже. За 4 минуты обработано около 120 млн., за 8 - до 200. 
Уже пятая часть обработана... Увы, опять OutOfMemoryException. Утешает то, что в 64 разрядах обработка обещает быть
быстрее. Миллиард на 32 разрядах - это экстрим... 

Что теперь? Надо попробовать задачу построения триплетов в целых кодах. Заведу отдельный проект. 

20140410 08:00
Пора вернуться к проекту и восстановить его работоспособность. Осталось немало мусора, который мешает разобраться
в существе преобразований. Буду устранять мусор и специфицировать систему. Ключевым классом является StringIntCoding.

========= public class StringIntCoding =========
Класс содержит три ячейки PaCell: собственно таблицу пар <int, string>, индекс по коду, индекс по идентификатору.
Индекс по коду устроен естественным образом в порядке записей основной таблицы. Это означает, что предполагается, что
при добавлении пар в таблицу, целочисленный код всегда увеличивается. Это свойство используется тем, что кодовый
индекс не сортируется.

Предполагается, что значения класса эволющионируют следующим образом. При конструировании, формируется пустая таблица
с пустыми индексами. Далее предполагается (многочисленные) добавления новых идентификаторов методом 
Dictionary<string, int> InsertPortion(string[] portion);
Прямым результатом метода будет включение набора идентификаторов в таблицу идентификаторов. Дополнительным результатом
будет формирование словаря, содержащего идентификаторы всех из portion и их коды. 

Как работает InsertPortion?
1. Все ячейки объекта закрываются.
2. Главная ячейка перемещается в файл sourceCell и заводится пустая emptyCell (содержащая 0 элементов) ячейка,
главная ячейка обнуляется и обозначается targetCell
3. 
 


 

