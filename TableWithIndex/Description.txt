
Демонстрационный проект TableWithIndex

Цель демонстрации - показать как можно сделать аналог индексации столбцов для традиционной таблицы данных

Суть программы
Сначала определим действия в терминах SQL и реализуем их.
1. Предполагается, что внешним образом заведена (пустая) таблица.
2. Подсоединяемся к ней, уничтожаем индексы, уничтожаем предыдущие данные. 
Создаем три колонки строкового типа, одну назвом id, 
другую - name, третью - fd. Третья нужна для проверки правильности выборок.
3. Заполняем таблицу данными из XML-файла. Берем информацию о персонах, орг-системах, документах.
4. Строим индексы двух первых колонок.
5. В цикле по собранному в специальный массив набору идентификаторов, делаем серию запросов SELECT,
а по собранному в другой массив текстовым образцам, делаем серию запросов на частичное совпадение.
6. В цикле, уничтожаем записи по набору идентификаторов.
7. В цикле, добавляем записи по набору идентификаторов
8. После уничтожения и добавления, выполняем запросы пункта 5.

PolarTest

1. Строится таблица данных, имеющая несколько столбцов. Столбцы могут быть примитивного типа (int, long, string,...).
Один из столбцов - deleted, булевкое значение true означает уничтожение записи.  
2. Таблица реализуется как ячейка свободного формата. Это позволяет достаточно просто добавлять новые записи, позволяет
сканировать записи. Проставляя в поле deleted значение true, позволяет уничтожать записи. Кроме сканирования, доступ
к записям предполагается по offset'у записи.
3. Определяется класс PIndex<T>. Параметр класса - тип колонки. Логически, класс представляет собой множество пар
{значение столбца, offset записи}, каждая пара вычисляется на основании записи. Причем это множество организовано
так, что по значению столбца или по схожести со значением столбца, выявляется одна или несколько записей, в 
которой есть данное совпадение или схожесть. 

Рассмотрим какой должна быть индексация для реализации через PolarDB. Сначала определим полуиндекс. Полуиндексом
назовем множество пар <key, value>. Полуиндекс реализуем в виде пары файлов - ячеек iname.pac и iname.pxc. Оба представляют
значение одного типа [{T, long}]. Если ячеек нет, то при инициализации индекса, они создаются. Рассмотрим методы для
полуиндекса:

void Load(IEnumerable<object[]> seq);
- object[] - пара значений key-value
Метод загружает последовательность в ячейку свободного формата. Потом значение переписывается в ячейку фиксированного формата
и сортируется по ключу. Полуиндекс готов к работе. 

long FindFirst(object sample);
- sample - объект типа T. Для T обределена операция сравнения, сравнение совместимо с тем, с которым производилась сортировка.
Если пара не найдена, выдается Int64.MinValue. Поиск производится в pxc, уничтоженные записи пропускаются.

IEnumerable<long> FindAll(Func<object, int> compare);
- функция compare задает сравнение ключа (object) с чем-то внешним, результат - как обычно. Функция должна быть совместимой
с Compare() для object. Поиск производится в pxc, уничтоженные записи пропускаются.

void Delete(object key, object value);
- Делает отметку deleted в обоих ячейках для записей, полностью, совпадающих с образцом. ПРЕДПОЛОЖИТЕЛЬНО, если value == null,
объект не проверяется.

void Append(object key, object value);
- добавляет запись к ячейке свободного формата, производит новое вычисление ячейки фиксированного формата и производит 
сортировку. Поля с признаком deleted могут переписываться или нет.

void Replace(object key, object value, object newvalue);
- изменяет в обеих таблицах запись {key, value} на {key, newvalue}

 
Предположим, нам требуется выстроить векторный индекс. То есть, в исходной записи (располагающейся в какой-то момент
по смещению offset), имеется набор идентификаторов других записей. Нужна таблица, структуры [{id, offset}] такая, что все
все offset'ы c одинаковым id, представляют ссылки на записи, в которых есть указания на данный идентификатор. 

Допустим, мы ничего не меняем, полуиндекс у нас есть. Есть у нас и выборка FindAll, дающая множество результатов. Наверное, 
речь идет только о заполнении таблицы. И даже метод Load не потребуется менять. Только подавать надо будет идентификаторы
по другой схеме. Для каждой записи и для каждой ссылке из записи, формируется множество пар {ссылка, offset записи}.
Далее - по схеме. Но потребуются некоторые дополнения для полуиндекса. Мелкое дополнение, другой вариант метода поиска всех:

IEnumerable<long> FindAll(object sample);

Для Append'а также желательно наличие другого варианта метода:

void Append(IEnumerable<object[]>);

подающий поток новых элементов. 
Эти варианты не обязательные, но могут несколько влиять на производительность обработки.

А вот изменение схемы уничтожения и замены значения - обязательны. Потому что уничтожать надо не по ключу, а по значению.
Для базового случая, со скалярным индексируемым значением, уничтожать и заменять можно по значению. Но это может стать
дорогостоящей операцией. Универсальным решением является наличие в полуиндексе индексатора по значению. Тогда во всех случаях
мы эффективно выходим на нужные значения или множества значений. 

Вот придумал новую схему (полу) индексирования. Пусть теперь у нас есть последовательность пар ключ-значение в виде ячейки
свободного формата. Добавим два массива (последовательность длинных целых) свободного или фиксированного формата в которые
поместим offset'ы пар упорядоченные по ключу и значению, соответственно. Схема достаточно экономна. Возможно имеет преимущества
в эффективности (производительности). Только надо продумать как производить редактирующие воздействия.

Я обдумывал ситуацию, решил, что надо попробовать и, на этой основе, делать выводы. Но, по крайней мере для векторной индексации,
подход выглядит довольно интересным. Есть соображение, что можно отказаться от промежуточного множества пар, но это - не всегда,
а только для скалярного индекса и некоторых схем доступа к данным записи. В чем достоинство PolarDB - можно создавать 
специализированную схему хранения и обработки.


 
===============
Описание пакета (класса) FreeIndex

Экземпляр класса представляет собой индекс для таблицы. Таблица есть вход PaEntry последовательности записей. Причем первый 
(нулевой) элемент записи - поле deleted, указывающее не возможную уничтоженность записи. При конструировании экземпляра
класса FreeIndex нужно указать путь к директории хранения ячеек индекса вместе с идентификатором, который пользователь
определяет индексу. Нужно также указать таблицу и поле таблицы (колонку), на основе значений которого формируются индексные
данные. Если поле не используется (см. далее), надо указать значение -1. Вместо поля, можно указать функцию, вычисляющую по 
записи значение с интерфейсом IComparable. 

Индекс состоит из нескольких ячеек свободного формата, размещаемых по указанному пути. Всегда присутствуют две ячейки, назовем
их "большой индекс" и "малый индекс", представляющие собой последовательность длинных offset'ов для базовой таблицы. Таблица
может расти, но не может уменьшаться. Выбывающие из таблицы записи помечаются как deleted. При формировании индекса, заполняется
большой индекс, при росте таблицы - малый индекс. Значения большого индекса и малого индекса отсортированы в соответствии с 
некоторым (см. позже) отношением порядка. Большой индекс сортируется однократно, при создании, малый индекс сортируется при 
текущем добавлении элементов. Убавление, добавление и изменение записей выполняется снаружи индекса.
При уничтожении записи отмечается поле deleted, для индексов не формируется никакого действия. Поле deleted используется 
динамически при выполнении функций доступа. 
Добавление записи. Записи добавляются в базовую таблицу и, после их добавления, индексам "сообщается" о добавленной записи. 
Эта информация размещается в малом индексе и индекс пересортируется. Поскольку координатная система не переиспользуется, 
проблем с добавлением и убавлением записей не видно. Изменение записи выполняется через уничтожение (deleted) предыдущего 
варианта и добавления нового. Видимо возможна и другая схема, но пока она не продумана.

Главная функция индекса - по предложенному условию или значению, выдать координату одной записи или координаты многих записей, 
удовлетворяющих этому условию или значению. Для экономии, как правило, в индексе хранится только как бы итоговый результат -
последовательность координат ячеек, упорядоченная по указанному при формировании критерию. Причем значения, на которых 
вычисляется критерий, остаются "на своих местах" в базовой таблице. В некоторых случаев, этого недостаточно. Например, при
множественности имен в колонках и других случаев необходимости векторного индекса. 

Векторный индекс - это встроенная в индекс таблица, устанавливающая соответствие между значениями определенного типа и 
координатой внешней записи. Сортировка записей во внутренней таблице производится по значениям. Выборки - традиционны, по 
заданному значению или критерию выбираются первая координата или все координаты, удовлетворяющие критерию. Поскольку 
векторный индекс непрямую не связан с конкретным полем записи, к тому же количество пар в векторном индексе может не совпадать
с количеством записей в базовой таблице, заполнение векторного индекса выполняется специальным методом. Корректирование -
другим методом. Внутренняя таблица может содержать индексаторы под обеим полям. Это, в частности, позволяет корректировать 
векторный индекс в случае удаления внешних элементов. Например, снаружи удалена запись с координатой C0, можно выявить все 
записи в таблице индекса с этой координатой и пометить как уничтоженные. 

Вопрос с неочевидным ответом: нужно ли конструкцию векторного индекса воспроизводить в составе FreeIndex или это должен быть
другой класс. Разберусь.

Похоже также, векторный индекс можно использовать и в "скалярных" целях. Например, в случае иерархии сортировок, можно значения
разных полей объединить в одном значении векторного индекса. 

Буду разрабатывать движок для Тургунды и совершенствовать представления об индексации. 



 


        