
Демонстрационный проект TableWithIndex

Цель демонстрации - показать как можно сделать аналог индексации столбцов для традиционной таблицы данных

Суть программы
Сначала определим действия в терминах SQL и реализуем их.
1. Предполагается, что внешним образом заведена (пустая) таблица.
2. Подсоединяемся к ней, уничтожаем индексы, уничтожаем предыдущие данные. 
Создаем три колонки строкового типа, одну назвом id, 
другую - name, третью - fd. Третья нужна для проверки правильности выборок.
3. Заполняем таблицу данными из XML-файла. Берем информацию о персонах, орг-системах, документах.
4. Строим индексы двух первых колонок.
5. В цикле по собранному в специальный массив набору идентификаторов, делаем серию запросов SELECT,
а по собранному в другой массив текстовым образцам, делаем серию запросов на частичное совпадение.
6. В цикле, уничтожаем записи по набору идентификаторов.
7. В цикле, добавляем записи по набору идентификаторов
8. После уничтожения и добавления, выполняем запросы пункта 5.

PolarTest

1. Строится таблица данных, имеющая несколько столбцов. Столбцы могут быть примитивного типа (int, long, string,...).
Один из столбцов - deleted, булевкое значение true означает уничтожение записи.  
2. Таблица реализуется как ячейка свободного формата. Это позволяет достаточно просто добавлять новые записи, позволяет
сканировать записи. Проставляя в поле deleted значение true, позволяет уничтожать записи. Кроме сканирования, доступ
к записям предполагается по offset'у записи.
3. Определяется класс PIndex<T>. Параметр класса - тип колонки. Логически, класс представляет собой множество пар
{значение столбца, offset записи}, каждая пара вычисляется на основании записи. Причем это множество организовано
так, что по значению столбца или по схожести со значением столбца, выявляется одна или несколько записей, в 
которой есть данное совпадение или схожесть. 

Рассмотрим какой должна быть индексация для реализации через PolarDB. Сначала определим полуиндекс. Полуиндексом
назовем множество пар <key, value>. Полуиндекс реализуем в виде пары файлов - ячеек iname.pac и iname.pxc. Оба представляют
значение одного типа [{T, long}]. Если ячеек нет, то при инициализации индекса, они создаются. Рассмотрим методы для
полуиндекса:

void Load(IEnumerable<object[]> seq);
- object[] - пара значений key-value
Метод загружает последовательность в ячейку свободного формата. Потом значение переписывается в ячейку фиксированного формата
и сортируется по ключу. Полуиндекс готов к работе. 

long FindFirst(object sample);
- sample - объект типа T. Для T обределена операция сравнения, сравнение совместимо с тем, с которым производилась сортировка.
Если пара не найдена, выдается Int64.MinValue. Поиск производится в pxc, уничтоженные записи пропускаются.

IEnumerable<long> FindAll(Func<object, int> compare);
- функция compare задает сравнение ключа (object) с чем-то внешним, результат - как обычно. Функция должна быть совместимой
с Compare() для object. Поиск производится в pxc, уничтоженные записи пропускаются.

void Delete(object key, object value);
- Делает отметку deleted в обоих ячейках для записей, полностью, совпадающих с образцом. ПРЕДПОЛОЖИТЕЛЬНО, если value == null,
объект не проверяется.

void Append(object key, object value);
- добавляет запись к ячейке свободного формата, производит новое вычисление ячейки фиксированного формата и производит 
сортировку. Поля с признаком deleted могут переписываться или нет.

void Replace(object key, object value, object newvalue);
- изменяет в обеих таблицах запись {key, value} на {key, newvalue}

 
Предположим, нам требуется выстроить векторный индекс. То есть, в исходной записи (располагающейся в какой-то момент
по смещению offset), имеется набор идентификаторов других записей. Нужна таблица, структуры [{id, offset}] такая, что все
все offset'ы c одинаковым id, представляют ссылки на записи, в которых есть указания на данный идентификатор. 

Допустим, мы ничего не меняем, полуиндекс у нас есть. Есть у нас и выборка FindAll, дающая множество результатов. Наверное, 
речь идет только о заполнении таблицы. И даже метод Load не потребуется менять. Только подавать надо будет идентификаторы
по другой схеме. Для каждой записи и для каждой ссылке из записи, формируется множество пар {ссылка, offset записи}.
Далее - по схеме. Но потребуются некоторые дополнения для полуиндекса. Мелкое дополнение, другой вариант метода поиска всех:

IEnumerable<long> FindAll(object sample);

Для Append'а также желательно наличие другого варианта метода:

void Append(IEnumerable<object[]>);

подающий поток новых элементов. 
Эти варианты не обязательные, но могут несколько влиять на производительность обработки.

А вот изменение схемы уничтожения и замены значения - обязательны. Потому что уничтожать надо не по ключу, а по значению.
Для базового случая, со скалярным индексируемым значением, уничтожать и заменять можно по значению. Но это может стать
дорогостоящей операцией. Универсальным решением является наличие в полуиндексе индексатора по значению. Тогда во всех случаях
мы эффективно выходим на нужные значения или множества значений. 

Вот придумал новую схему (полу) индексирования. Пусть теперь у нас есть последовательность пар ключ-значение в виде ячейки
свободного формата. Добавим два массива (последовательность длинных целых) свободного или фиксированного формата в которые
поместим offset'ы пар упорядоченные по ключу и значению, соответственно. Схема достаточно экономна. Возможно имеет преимущества
в эффективности (производительности). Только надо продумать как производить редактирующие воздействия.
 

 


        