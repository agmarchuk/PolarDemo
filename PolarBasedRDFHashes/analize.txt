Граф представлен ячейками:
1) типлеты объектных предикатов
s_code p_obj_code o_code : Int32 x Int32 x Int32
ячейка сортируется по первым двум числам.
для поиска по объеекту необходима дополнительная ячейка(индекс) offset_o : Int64
2) коды идентификаторов генерирутся встроенным getHashCode()
id_code id : Int32 x string 
строка не фиксированной длинны.
сортировать такие ячейки нельзя.
для поиска пары по коду необходима дополнительная ячейка(индекс) offset_id : Int64
3) квадрики данных
s_code p_data_code data_code lang : Int32 x Int32 x Int32 x char[2]
Для языка размер строки ограничен, это упрощение с одной стороны, что бы не выносить язык в отдельную ячейку.
С другой стороны это позволяет сортировать последовательность по первым двум числам: субъекту и предикату.  Это позволяет не создавать допролнительную ячейку (индекс).
4) ячейка данных такая же как для идентификаторов с подобным индексом.
5) ячейка объектных предикатов подобна ячейки идентификаторов и подобная дополнительнная ячейка индекс.
6) ячейка предикатов данных подобна ячейки идентификаторов и подобная дополнительная ячейка индекс.

Сортировать ячейку индекса с длинными целыми Int64 быстрее, чем саму ячейку, например, трпилетов, потому что размер перемещаемого элемента последовательности меньше.
Но ненаного, больше, чем разница, времени займёт создание заполнение дополнительной ячейки.
На это указвает разница времён: 1) создания индексов графа, включая 4 дополнительные: индекс субъектов триплетов, индекс субъектов квадриков данных, индекс (эти два индекса были излишни)
субъекта и предиката триплетов и субъекта и предиката квадриков данных. от 300 до 350сек.
2) создание индексов графа без этих четрырёх, но с сортировкой ячеек трипетов и квадриков 200сек.
Сортировка элементов ссылок класса vs объектов структуры.
Пишут, что сортируются объекты структур быстрее http://www.gamedev.ru/code/forum/?id=166353
Для сортировки по субъекту и предикату используемый тип ключа межт быть структуррой или классом. Разницы при сортировке 10 000 000 структура выигрывает очень мало.
Если в проекте TripleIntCoding класс PairInt заменить на структуру, разница сортировки 10 000 000 в 7мс.(=26мс-19мс).

Ранее использовался массив bool(4 массива: Int32.Min-Int32.Min/2, Int32.Min/2-0, 0-Int32.Max/2, Int32.Max/2- Int32.Max), для выполнения тех же функция, что HashSet<int>.
но HashSet<int> очевидно лучше подходит. Создание таких больших массивов занимает 11мс, и 4гб оперативной памяти. Замена этих массивов на  HashSet<int>(3 использования: для идентификаторов, объектных и предикатов данных) привела к ускорению загрузки данных
с 100-80сек. до 70-50сек.

Если в ячейке идентификаторов ограничить размер строки, её можно сортировать. Например, при ограниячени длины идентификатороа 20 символов,
сортировка происходит с одним разделением/слиянием. Тогда не нужна дополнительная ячейка(индекс) с длинными целыми.
Ускорение загрузки индексов, с сортировкой идентификаторов на 25мс. (=170мс - 144мс).



