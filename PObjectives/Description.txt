
Замысел проекта заключается в том, чтобы попробовать реализовать примитивный подход к объектному представлению 
базы данных средствами PolarDB. Пусть есть множество объектов нескольких классов. Для примера, пусть у нас будет класс
персон и класс городов. А между ними - отношение "проживает". Мы хотим работать с объектами классов
Person и City причем так, что все хранится в базе данных. 

В качестве начальной базы данных, создадим две последовательности вида:
Person = [id: string, name: string, age: int, live: id];
City = [id: string, name: string]

Понятно, что id может быть скрытым полем, что id может быть кодом какого-то вида. Менее очевидно, что для City есть 
скрытое поле - последовательность персон, проживающих в данном городе. Совсем не очевидны вопросы индексирования. 

Таким образом, C# классы Person и City выглядят следующим образом: 
class Person
{
  string name;
  int age;
  City live;
}
class City
{
  string name;
  Person[] live;
}
У полей этих классов можно и нужно определить свойства Get, Set. Должен быть конструктор, возможно, деструктор.

Соответственно, когда мы имеем переменную класса Person, понятны варианты действий:
Person p = new Person();
p.name = "Иванов";
p.age = 33;
City c = p.live;

Как это реализуется. В экземплярах класса Person, как и в экземплярах других классов, реально хранится только 
служебный код. Возможно, это id. Но это может быть и значение класса PaCell. Допустим второе.
Тогда чтение поля p.name будет чем-то вроде (string)ent(p).Field(1).Get(). Простая изолированная функция, 
способная участвовать в выражениях.
p.age = 34;        
как ни странно, можно реализовать просто, пользуясь атомарностью поля:
ent(p).Field(2).Set(34);

В других случаях, это не проходит. При реализации 
p.name = "Петров";
Надо создавать другую запись, а данную уничтожать. 
Теперь что означает p.live в контексте чтения. В принципе, речь идет о чтении хранимого идентификатора, обращение
с этим идентификатором к таблице Cities и получение кода или указателя города. Обратное действие сложнее. Если для 
конкретного города мы хотим получить множество проживающих персон, надо "сканировать" таблицу персон и выявлять нужные. 
Если таблица персон имеет индекс, связанный с кодом города, такое сканирование можно заменить бинарным поиском. 
Тонкость заключается в том, что мы не собираемся формировать реальное множество, нам хватит итератора. Можно говорить о 
Linq-формуле. 

Менее очевидными являются вопросы поиска значения или подмножества значений во множестве объектов заданного типа. 
Тут даже языкового варианта не находится. Наиболее естественны выглядит решение, когда нужные множества есть как
IEnumerable или IQueryable и от них можно начинать Linq-вычисления.
Напр. есть переменная 
personSet
от которой можно начать Where, Select и т.д.
Соответственно, new Person() неявно добавляет члена в коллекцию, p.Remove() - убавляет. 

Технически, можно сделать статическую переменную в классе Person, может метод будет называться All, может по-другому. 

Есть еще важные вопросы. Например, как быть, когда запись не уничтожается, а модифицируется. На нее могут быть установлены
разные ссылки. 

Надо "переварить" то, что написал и обдумывал. А в приципе, можно уже где-то начинать кодирование. 

  

 


 
 
