
Замысел проекта заключается в том, чтобы попробовать реализовать примитивный подход к объектному представлению 
базы данных средствами PolarDB. Пусть есть множество объектов нескольких классов. Для примера, пусть у нас будет класс
персон и класс городов. А между ними - отношение "проживает". Мы хотим работать с объектами классов
Person и City причем так, что все хранится в базе данных. 

В качестве начальной базы данных, создадим две последовательности вида:
Person = [id: string, name: string, age: int, live: id];
City = [id: string, name: string]

Понятно, что id может быть скрытым полем, что id может быть кодом какого-то вида. Менее очевидно, что для City есть 
скрытое поле - последовательность персон, проживающих в данном городе. Совсем не очевидны вопросы индексирования. 

Таким образом, C# классы Person и City выглядят следующим образом: 
class Person
{
  string name;
  int age;
  City live;
}
class City
{
  string name;
  Person[] live;
}
У полей этих классов можно и нужно определить свойства Get, Set. Должен быть конструктор, возможно, деструктор.

Соответственно, когда мы имеем переменную класса Person, понятны варианты действий:
Person p = new Person();
p.name = "Иванов";
p.age = 33;
City c = p.live;

Как это реализуется. В экземплярах класса Person, как и в экземплярах других классов, реально хранится только 
служебный код. Возможно, это id. Но это может быть и значение класса PaCell. Допустим второе.
Тогда чтение поля p.name будет чем-то вроде (string)ent(p).Field(1).Get(). Простая изолированная функция, 
способная участвовать в выражениях.
p.age = 34;        
как ни странно, можно реализовать просто, пользуясь атомарностью поля:
ent(p).Field(2).Set(34);

В других случаях, это не проходит. При реализации 
p.name = "Петров";
Надо создавать другую запись, а данную уничтожать. 
Теперь что означает p.live в контексте чтения. В принципе, речь идет о чтении хранимого идентификатора, обращение
с этим идентификатором к таблице Cities и получение кода или указателя города. Обратное действие сложнее. Если для 
конкретного города мы хотим получить множество проживающих персон, надо "сканировать" таблицу персон и выявлять нужные. 
Если таблица персон имеет индекс, связанный с кодом города, такое сканирование можно заменить бинарным поиском. 
Тонкость заключается в том, что мы не собираемся формировать реальное множество, нам хватит итератора. Можно говорить о 
Linq-формуле. 

Менее очевидными являются вопросы поиска значения или подмножества значений во множестве объектов заданного типа. 
Тут даже языкового варианта не находится. Наиболее естественны выглядит решение, когда нужные множества есть как
IEnumerable или IQueryable и от них можно начинать Linq-вычисления.
Напр. есть переменная 
personSet
от которой можно начать Where, Select и т.д.
Соответственно, new Person() неявно добавляет члена в коллекцию, p.Remove() - убавляет. 

Технически, можно сделать статическую переменную в классе Person, может метод будет называться All, может по-другому. 

Есть еще важные вопросы. Например, как быть, когда запись не уничтожается, а модифицируется. На нее могут быть установлены
разные ссылки. 

Надо "переварить" то, что написал и обдумывал. А в принципе, можно уже где-то начинать кодирование. 

20140313 22:01
Попробую написать некоторую реализацию замысла. Сразу буду ориентироваться на редактирование данных.
Для этого, мне понадобится FlexIndex. Логика построения гибкого индекса следующая. Он существует при
простой последовательности свободного формата. Причем элементы последовательности - записи с первым
полем deleted. Семантика поля в том, что логически, последовательность представляет собой множество
записей в которых deleted установлен в false. Добавления к последовательности производятся стандартным
AppendElement(), убавление - установкой поля deleted. При опорной последовательности может существовать
произвольное количество "гибких" индексов. Индекс создается при существующей (возможно нулевой) 
последовательности и постоянно синхронен с последовательностью если при каждом добавлении элемента
через AppendElement, ссылку на добавленную запись добавлять в индекс методом AppendEntry(). Синхронизация
по убавлению элементов осуществляется автоматически.  
Индекс строится по некоторой, в общем случае виртуальной, колонки опорной последовательности через задаваемую на
элементах последовательности функцию KeyProducer. И по значениям этой "колонки" индекс как бы сортируется.
Это добавляет к последовательности следующую функциональность - можно получать указатель на первую запись или
поток указателей на все записи, удовлетворяющие либо совпадению ключа с образцом, либо нулевому уровню т.н.
глубины, вычисляемой на значениях элементов последовательности. Определитель глубины задается
функцией elementDepth, вычисляемой на элементах записи. Функция глубины должна быть согласованной с порождающей
индекс функцией KeyProducer.

Как должно выглядеть объектное построение? Исходным представляется понятие коллекции элементов определенного
класса. Т.е. элемент без коллекции не существует. Можно этот факт "замаскировать" если коллекция элементов
одного класса только одна. Но, в общем случае, collection.NewElement() порождает новый элемент именно в
этой коллекции. Обратным действием является collection.RemoveElement(element). Также, для уничтожения
определен прямой метод element.Remove(). Как работать с элементами (коллекций), уже обсуждалось, теперь
рассмотрим работу собственно с коллекциями. Главное действие - получение по идентификатору элемента его 
экземпляра. Экземпляр элемента представлен в подходе минимально - его указателем PaEntry, и, наверное,
некоторой дополнительной информацией, которая сейчас неясна. Соответственно, у коллекции всегда есть
индекс по полю идентификатора. Другие индексы создаются по потребности. 
Элемент коллекции представляет собой запись. Два поля записи - скрытые. Поле deleted и поле id. Пусть 
они будут первым и вторым в записи. Другие поля имеют отображение (Mapping) на свойства C# класса, 
сопоставляемого с типом элементов коллекции. Кроме реальных полей элементов последовательности, 
могут существовать виртуальные поля. Виртуальное поле - это когда в C# классе поле есть, а в структуре записи
- нет, но есть функция отображения "элемент коллекции" -> значения поля класса. Формирование и индексацию
виртуальных полей рассмотрим позже. 
Поле, содержащее измеримые значения, может быть индексировано. И по этому полю можно производить поиск типа:
collection.Elements().First(предикат) или .Where(предикат) и др. аналогичные.

Но детали могут потребовать не такой простой методики трансляции Linq-выражений.

Коментарии к классу PObjectiveCollection
Мы будем реальный задаваемый тип элемента eType погружать в расширенный тип элемента (Extended Element Type)
такой, что eeType является записью с двумя предопределенными колонками deleted и id. А третья колонка имеет 
eType. Альтернативным решением было бы наложить услвия на внешнее определение типа, так я таже делал.

В качестве типа (ключевого) идентификатора принимаем целое. Значение идентификатора - номер созданного 
элемента коллекции, начиная с 0. Коллекция хранит номер очередного идентификатора idNew. Но это хранение является 
явным только для объектного представления - экземпляра класса PObjectiveCollection. Во внешних данных,
хранение idNew является неявным. Его можно определить по последней добавленной записи в опорную 
последовательность. Однако, в силу свободного формата ячейки хранения, выйти на эту запись не так просто.
Если последовательность не подвергалась чистке, т.е. уничтожению deleted элементов, то idNew совпадает с длиной
последовательности. На последний элемент можно выйти через базовый индекс по ключевому идентификатору. Надо 
взять последний элемент малой индексной таблицы, а если ее нет, то последний элемент большой. При таком подходе,
при создании индексной таблицы, ее можно не сортировать. Вычисление idNew видимо потребует добавления к 
FlexIndex.

Также скорее всего, понадобится счетчик counter. Для существующей коллекции, это количество элементов минус количество 
уничтоженных элементов.

Формирование idNew и counter можно совместить с сканированием последовательности при разогреве (warmup) базы данных.

Принимаются решения: idNew совпадает с количеством элементов, пока мы не займемся чисткой мусора в коллекции.
По counter'у - при первом обращении, производится вычисление сканированием, далее, counter отслеживается
при эволюции коллекции. Неинициированное значение counter'а = -1.

Корректирую терминологию и код. Теперь (ключевой) идентификатор опорной последовательности будем называть 
ключем (key). 

Теперь, для продолжения, надо разработать семантику класса PObjectiveElement. Предполагается, что именно этот
класс будет наследоваться и доопределяться и он является главным участником обработки на C#.

Суть класса - задать форму вложения и функциональность для элементов коллекции. По коллекции, можно порождать
новые элементы, можно уничтожать элементы, можно находить по коду. Можно также сканировать элементы коллекции.
Пока достаточно. Экземпляры класса PObjectiveElement должны содержать ссылку на коллекцию и, главное -
поляровскую ссылку (PaEntry) на элемент опорной последовательности коллекции. Для начала, достаточно. Напишу
начало кода.

Написал. Определил поля и конструктор. Конструктор надо "спрятать" пусть он будет internal. Возвращаюсь к коллекции.

Работаю над NewElement. Поскольку "пустой" новый элемент редко будет иметь смысл, этот метод всегда предполагается
со значением, которое и сформирует новый элемент. Значение - объектное поляровское представление структуры eType.

Сделал. Уже пора кое-что испытывать. Теперь сделаю для коллекции простые методы: Elements() и ElementValues(). А
для объектного элемента - метод Get().

Теперь попробую испытать сделанное. Заведу коллекцию персон. Добавлю в нее несколько и посмотрю что там накопилось. 

20140315 07:52
Испытания прошлый раз прошли успешно, но пока я мало что сделал. 
Продумывание получающейся конструкции, дает основание полагать, что нужен еще один уровень группирования - назовем
его "база данных". Итак, база данных состоит из коллекций, коллекции состоят из элементов различных типов.
В элементе есть ссылка на содержащую его коллекцию. В коллекции есть ссылка на охватывающую базу данных. В
базе данных можно явно запросить коллекцию по ее имени (наверное, идентификатору). В коллекции можно запрашивать
элементы по ключу. Получается конструкция типа MongoDB, только там базы данных называются namespaces. Отличие
нашего решения в том, что в MongoDB это единственный вариант устройства базы данных, у нас - один из довольно 
большого количества вариантов. 

Итак, создаю класс PObjectiveDatabase и прописываю все варианты переходов от одних структур к другим.

18:01
Ну так, более или менее начинает работать. Пока нет схемы обновления индексов, но это мелочи. С коллекциями и 
базами данных все не слишком сложно - базовые классы годятся на почти все случаи. Для коллекций есть некоторая 
специлизация через тип записи. Пока это не "напрягает". Но далее, элементы последоватлеьностей хочется снабдить
C# классом, наследником PObjectiveElement, но обладающим, как минимум некоторыми (полезными) свойствами (properties).
Пока не знаю как это делать. Попробую через параметризацию типом. Как-то так еще не приходилось делать. 

20140316 20:56
Я вчера застрял на придумывании схемы определения базовых классов системы. Как-то плохо получается. Вся эта 
параметризация мне нужна для реализации классов, являющихся расширением PObjectiveElement. Суть проблемы
заключается в том, что в непараметризованном классе PObjectiveCollection нужно иметь возможность выдачи
элементов класса-наследника PObjectiveElement. При этом, в классе-наследнике могут быть поля и свойства, которых
нет в родительском. Возможно надо сделать конструктор, который по значению родительского класса создает дочерний
элемент. Возможно, не надо поддерживать добавляемые поля, т.е. не надо их допускать, обходиться свойствами. Хотя
вряд ли. Нам понадобятся и скалярный и верторный индексы. 

Проведу программный эксперимент.   

20140319 06:18
Проболел три дня, совсем не мог работать по причине неработоспособности головы. А бросил я работу на интересном месте.
Я как раз, наконец, придумал общую схему реализации параметризации. Я ее изложил в виде модуля Experiment. Он независимый,
носит иллюстративный характер. Теперь я даже пространство имен ему изменил, чтобы в рабочем варианте использовать
имена классов, методов и свойств. Суть решения в следующем. Базовой "осью" проходит непараметризованный вариант. 
База данных, коллекция, элемент - это главные участники. И для них определены базовые методы типа 
    class Collection
    {
        public IEnumerable<Element> Elements();
        public Element Element(int key);
    }
Но также там есть их эквиваленты для назначения специальный объектных представлений для элемента
    class Collection
    {
		...
        public TElement Element<TElement>(int key) where TElement : Element, new()
        {
            Element el = this.Element(key);
            var res = new TElement() { inCollection = el.inCollection, entry = el.entry };
            return res;
        }
    }
Главное, в этих определениях ограничения на тип-параметр. Ну и изложена некоторая схема реализации, которая должна 
сработать. В общем, окончательное решение достаточно логичное и протое, но как-то долго я до него шел. Сейчас
кучу кода придется переделывать обратно.


 


   


 

 
 

    

 


 
 
