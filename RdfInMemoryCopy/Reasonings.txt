Попытка сформировать подход к архитектуре RDF-обработчика

Сейчас я изучаю возможность использования спецификаций dotnetrdf. 

Класс Graph

Graph вроде подходит в достаточной мере. Возможно, есть особенности в том, что у меня это еще и хранилище. 
Наверное, другой подход к хранилищу можно адаптировать и даже получить некоторые преимущества от этого.
Например, можно всю Sparql-обработку перевести в работу с хранилищем. Другим преимуществом может быть 
испоьзование графов временного или промежуточного хранения. Рассуждение здесь следующее: есть большой статический 
граф, доступный по выборкам множеству абонентов. Для абонента организуется хранилище, в которое "размещается"
статический граф и также временный граф или графы абонента. В таком варианте можно иметь большую гибкость для
конкретных абонентов. Правда непонятно что делать с желаниями абонентов производить изменения в статическом графе.

BaseURI я не очень понимаю. Вроде это как для XML-файла - URI немаркированного пространства имен. Пока мы не 
использовали таких средств.

IsEmpty - свойство, которое легко реализовать. Но опять же, мне такое свойство пока не требовалось.

NamespaceMap - вот эта "штука" уже нужна. В этом направлении работает Сергей. Что пока непонятно, так это то, как
эти карты будут сочетаться у различных графов. Вообще, семантика объединения графов и их совместной обработки
пока мне не понятна.
Детали можно посмотреть в: https://bitbucket.org/dotnetrdf/dotnetrdf/wiki/UserGuide/Using%20the%20Namespace%20Mapper

Свойства Nodes и Triples. Их довольно легко реализовать, хотя в моих построениях такие перечислители не требовались.
Нюанс заключается в различных подходах к узлам и триплетам.
По узлам согласование произвести достаточно просто. У нас есть сущности (кодируемые целыми) и литералы (кодируемые
длинными целыми). Первые относятся к URINode, вторые к LiteralNode. BlankNode я пока не использую. Наверно, можно
рассмотреть кодирование литералов также целыми.
С триплетами также проблема. В dotnetrdf нет исходного различия между объектными или необъектными триплетами. Хотя
всегда можно это выяснить через класс объекта (в тройке). Такая однородность возможно будет заметна для триплетов, в
которых используются узлы-параметры. 

Похоже, не все в порядке будет с адаптацией. Рассмотрим фрагмент использования dotnetrdf:
//Need a Graph first
IGraph g = new Graph();

//Create some Nodes
IUriNode dotNetRDF = g.CreateUriNode(UriFactory.Create("http://www.dotnetrdf.org"));
IUriNode createdBy = g.CreateUriNode(UriFactory.Create("http://example.org/createdBy"));
ILiteralNode robVesse = g.CreateLiteralNode("Rob Vesse");

//Assert this Triple
Triple t = new Triple(dotNetRDF, createdBy, robVesse);
g.Assert(t);

Что из фрагмента следует? Главное то, что триплет - самостоятелен и не требует контекста (в отличие от узлов).
Еще в других местах триплет превращается в стандарное текстовое 
 
Внимательное изучение документации показало, что я не прав. Граф неявно участвует в триплете через 
Graph/Node Factory для узлов. И если фабрики разные, то триплет не будет порожден. В общем, все
можно сделать. Только надо быстро формировать узлы по их кодам. Это потому что запросы будут 
производиться в кодах и ответы получаться также в кодах. 

20140708 08:28
Некоторый цикл размышлений закончился. Попробую выстроить конструкцию. Итак, делаю спецификацию "нашего"
RDF-движка. Базируемся на dotnetrdf. Берем то, что нам надо и пока не берем то, что не надо. Осторожно 
добавляем то, что в dotnetrdf отсутствует или сделано по-другому, но нам очень надо... Используем
другое пространство имен.

Выполним спецификацию в .cs файле

20140709 16:46
Решил попробовать реализовать протой вариант RDF-движка на базе наработок, сосредоточенных в данном проект.
Видимо будет дублирование, но это просто прикидка..

Заведу следующие проекты:
TProgram - программа-пускач
TDeclarations - определения пакета
TGraph - класс Graph
TTurtleParser - класс TurtleParser

20140710 13:05
Пора реализовывать узлы. Здесь видится следующий подход: узлы (пока) двух видов - ури и литералы.
Узлы кодируются, причем каждый вид по-своему. Для узлов есть также внетреннее представление. По коду
можно (очень быстро) построить объект, можно (быстро) найти внутренее представление, по нему можно 
создать внешнее (строковое) представление. Кодирование производится в обратном направлении внешнее
представление => внутренее представление => код. Разные коды соответствуют разным узлам.  
Для Uri-узлов верно и обратное - одинаковые коды соответствуют одинаковым узлам.

Для начала, реализую некорректный, но простейший метод кодирования - хеш-кодирование строк.
 







 



 
  
