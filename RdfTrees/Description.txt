Проект RdfTrees

Проект имеет целью проверить возможность построения хранилища триплетов в виде друх деревьев:
дерева сущностей и дерева литералов. Суть идеи заключается в формировании двух ячеек (структур)
вида:
EntitiesTree = [
  id: int,
  fields: [prop: int, off: longinteger]
  direct: [prop: int, ref: int]
  inverse: [prop: int, sources: [int]]
  ];
LiteralsTree = [
  prop: int,
  litpairs: [source: int, lit: Literal]
  ];

id, source - целочисленный код идентификатора сущности
sources - набор целочисленных кодов идентификторов сущностей
prop - целочисленный код идентификатора свойства
off - offset соответствующего элемента в последовательности LiteralsTree
lit - значение литерала

Дополнительные свойства структур.
1) Последовательность EntitiesTree упорядочена по идентификатору id.
2) Поле off "напрямую" указывает на элемент litpairs с нужным идентификатором и с 
согласованными prop и source.
3) Последовательность litpairs упорядочена по значению литерала. 

Данная пара деревьев позволяет эффективно выполнять почти все виды нужных запросов:
SpO, SpD,
spO, spD,
Spo, Spd

Для эффективного выполнения spo можно добавить бинарную шкалу
Запросы с неопределенным предикатом также можно выполнять эффективно. Не поддерживается
эффективность выполнения sPo, sPd, хотя их тоже можно выполнять с приемлемой производительностью.

Проект требует наличия биективного целочисленного кодирования, т.е. взаимно однозначного 
соответствия идентификатор-код (string-int), причем в обе стороны преобразования должны выполняться
быстро. Такое отображение будем называть таблицей имен.

Взаимодействие с таблицей имен будем осуществлять через астрактный класс с заданным интерфейсом
IStringIntCoding или чего-то аналогичного.    

Для ввода у нас будут данные формата turtle.

Описание класса DiapasonScanner
===============================

Класс предназначен для последовательностей срободного формата с фиксированным размером элемента.
Предполагается, что элементы последовательности упорядочены по значению ключа, представляемого
параметром класса. Ключ элемента вычисляется заданной функцией keyFunction по входу в элемент.
Класс имеет текущий элемент KeyCurrent, который вначале присваивается значению keyFunction на
первом элементе последовательности. Класс перебирает последовательно группы элементов 
последовательности с одинаковым ключем. Результатом очередного сканирования является диапазон
очередной группы "однородных" элементов. Диапазон фиксирует номер начального элемента и количество
элементов в группе.

 