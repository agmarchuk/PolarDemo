
Решил сделать "чистенький" проект по работе с "правильным" RDF. Имеется ввиду типизация полей данных.
Если я правильно понимаю стандарт RDF, значения полей данных могут быть типизированы. То есть,
объектом подобной тройки будет константа вида:
... "значение"^^<объект типа>

Если этой части константы нет, то подразумевается стандартная строка с известным типовым узлом:

"value"^^xsd:string
или 
"value"^^<http://www.w3.org/2001/XMLSchema#string>
 
Будем поддерживать: 
xsd:integer

В дальнейшем, добавим:
xsd:date
xsd:dateTime
xsd:boolean или как он там называется
xsd:number или как-то по-другому (xsd:decimal, xsd:double!) 
 
Другие типы можно будет добавлять по мере необходимости.

Теперь о языковой специализации. Если я правильно понимаю логику RDF, при его применении, фиксируется то же
значение типа, что и без указаний типа и специализатора - xsd:string.
И только в этом случае, этот специлизатор (@ru) может возникнуть. Почитаю стандарт. 

Почитал. Что-то там не сходится. Получается, что просто константная строка не сравнима с типизованной строкой,
так же как и строкой с языковым специализатором. В Turtle строка и типизованная строка идентичны. Я пойду дальше.
У меня будет храниться объединение:
RLiteral = 
	integer^integer,
	string^{s: sstring, l: sstring},
	date^longinteger,
	...

Ввод данных буду производить с помощью упрощенного парсера ttl.

Сначала отладил программу на стандартных данных. Построение базового портрета занимает на домашнем компьютере
23 мс. для 10 (стандартных) идентификаторов и это после разгона. Попробую загрузить берлинский миллион.

Загрузил. На берлинском миллионе, базовый портрет получается в первый раз за 2350 мс. Пять следующих 
портретов вычислены за 7 сек. При повторном запуске, результаты - лучше. Первый портрет - 42 мс., пять
следующих - 23 мс. База данных - 247 Мб. Загрузка данных и индексация производилась 40 сек. (15 сек. - загрузка).

Следующая задача, которую хочется решить - это гибкое управление сортировкой-выборкой. Я имею ввиду то, что
хотелось бы отсортировать индексы первично по субъекту (или объекту, соответственно) и вторично - по предикату.
Тогда можно будет производить выборки и по одному заданному субъекту и по паре субъект-предикат. Вроде ничто не
мешает. Посмотрю код.

Посмотрел, сделал. Загрузка в сортировкой по парам субъект-предикат и объект-предикат выполняется за 111 сек.
Построение портретов вроде работает. Пять портретов делаются за 25 мс. Теперь сделаю нужные процедуры.

Решил, что двойной сортировки недостаточно и теперь "главный" индекс объектных триплетов вычисляется по сортировке 
субъект-предикат-объект. Время загрузки почему-то уменьшилось. 
68 сек. загрузка.
Теперь появляются осмысленные результаты, потом надо будет их сравнить с вычисленными через Sparql.

57, 65, 213, 60, 53, 51  время=538

476 сек.
30 мс., 50 мс. - 6 прогонов первого теста.

20140212 04:29
Решил поработать. Сделал удобный вариант теста. Это 1 млн. берлинских триплетов. Это первый берлинский запрос
и это некоторая заметрая разница между тем, что получается и что можно было бы ожидать. Тестирование на
домашнем компьютере дает 26-30 мс. для выполнения 6 запросов с различными стартовыми точками (идентификаторами).
Это при фиксации только первого предложения Sparql-запроса. Использование фильтрующего второго - дает уже
515-528 мс., третьего - 685 мс. Добавление вычисления поля добавляет совсем не много - 700 мс. 
Если убрать фильтры, получится 540 мс. Но там заметно больше (раза в 4) веточек, которые ранее убирались 
фильтрацией. 

Задача номер 1 - сделать фильтрацию типа проверки существования триплета (существенно) более эффективной.

Этап 1.
Завожу массив битовых пар в виде массива целых чисел. Число битовых пар N_bpairs. Его надо будет вычислить.
Но пока его положу 8 М, т.е. число битов 16 М, число целых 0.5 M, что равно 524288, что соответствует 2**19.
Избыточность такой шкалы - 8, надеюсь этого хватит. Индекс массива битовых пар будет 2**23
Далее, для объектных триплетов вычисляю индекс как Hash(subject) xor Hash(predicate) xor Hash(object) и
оставляю в числе 23 бита. Операция xor в Си выражается символом ^. 
Полученным индексом я выбираю два бита (arr[ind >> 4] >> ((ind & 15) << 1)) & 3;
Два бита кодируют "попадание" триплета в данный код. 
0 - нет "попадания"
1 - есть единичное попадание
2 - есть несколько попаданий

Запись двухбитного кода в шкалу по индексу осуществляется оператором
arr[ind >> 4] = arr[ind >> 4] & (~(3 << ((ind & 15) << 1))) | ((value & 3) << ((ind & 15) << 1));
где v - записываемый код.

Наверное, надо оформить шкалу классом. Попробую.
Некоторый код написал. Пока шкала формируется "динамически" - в оперативной памяти и передпропуском тестов.
после "разгона", шкала вычисляется 1187 мс.
Сделаю проверку шкалы.

Проверка показала достаточно логичные результаты. Для нашего миллиона триплетов, 8 млн. позиций - пустые,
327 тыс. - единичные, 58 тыс - двойные. Ошибочных кодов нет.

Вроде получилось. Время выполнения 6 запросов - 306 мс. Но там есть "неудачный" (мало фильтрует), он 
среднее время несколько увеличивает. 

Теперь настало время проверить идею с формирование Linq-запросов, похожих на Sparql. Идея вырисовывается
следующей:
Для RDF-движка определяем методы, похожие на триплеты. 
IEnumerable<RPack> spo(this.IEnumerable<RPack> pack, object s, object p, object o);
Другие методы имеют такой же интерфейс (!) и называются аналогично: Spo, spO, Spd и т.д.
Причем большая буква символизирует то, что соответствующий параметр является "приемником" 
вычисляемых значений. Если эта буква маленькая, то это уже вычисленное значение или константа. 
Параметры s, p, o могут быть либо целым значением, либо строкой. В первом случае, это означает
индекс массива, где находится строка, соответствующая этому значению. Во втором случае, строковая
константа является собственно значением Entity. Для данных (d) множестов типов расширяется на
возможные типы данных: строки, целые, вещественные, даты, логические и т.д. В случае, когда
параметр помечен большой буквой, допустимо только целое значение индекса массива, куда будет 
записано то, что вычислено.    
Рассмотрим эти методы несколько подробнее. 
spo является фильтром. Этот метод определяет есть ли в хранилище объектный триплет с соответствующими
значениями субъекта, предиката и объекта и если есть, значение pack пропускается. Остальные варианты -
отбраковываются. Если есть неопределенное значение, то его надо определять. Соответственно, по известным
частям триплета порождается множество вариантов, которые "запускаются в оборот". 
Фильтр - это фильтр вариантов, задающий предикат фильтрации. Опция - дополнительная настройка над
потоком вариантов, размещающия неопределенным значением какую-то часть переменных и далее, вычисляющая 
или не вычисляющая эти значения. 
Объединение - некоторый разветвитель, обеспечивающий выполнение дизъюнкции наборов вариантов.

Попробую, что-ли...

Попробовал, получилось! Есть еще недоделки, но код вида:

                string bsbm = "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/vocabulary/";
                string bsbm_inst = "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/";
                // query 1
                object[] row = new object[3];
                int _produc = 0, _value1 = 1, _label = 2;
                var quer = Enumerable.Repeat<RPack>(new RPack(row, ts), 1)
                    .Spo(_produc, bsbm + "productFeature", bsbm_inst + "ProductFeature19")
                    .spo(_produc, bsbm + "productFeature", bsbm_inst + "ProductFeature8")
                    .spo(_produc, "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", bsbm_inst + "ProductType1")
                    .spD(_produc, bsbm + "productPropertyNumeric1", _value1)
                    ;

вполне похож на Sparql-прототип. И вполне легко формируется на основе прототипа. При этом, исполняется на
домашнем компьютере (на 1 млн.) за 61 мс.
 
Я несколько приостановился на типах данных (литералов). В принципе, в разделе Triple определен класс Literal,
которым надо пользоваться в этих местах. Соответственно, для spD аргумент данных должен быть оформлен следующим
образом: либо это целый индекс, либо значение класса Literal. В массиве хранения данных row, позиция значения
переменной поля будет занимать значение типа Literal. Надо сначала вернуться к вводу данных и задействовать 
тип, если он указан.

Первый тест удалось выполнить полностью. Результаты совпали. Надо сделать некоторые другие тесты.

Сделал тесты 1, 2, 3, 6
Результаты прогона на домашнем компьютере тестов на 1 млн. дают следующие резвльтаты:
422, 66, 876, 1801
Не очень, но это измерения.
83, 2, 270, 1167 - второй прогон

20140217 10:50
Я сделал довольно принципиальную ошибку. Это касается использования шкалы для проверки существования конкретного
(объектного) триплета. Я посчитал, что выгодно шкалу коидровать двумя битами с кодами 0 - нет триплета, 1 - есть один
триплет с данным кодом, 2 - есть больше одного триплета с данным кодом. Однако, данная логика в вопросах проверки
не сработала. Дело в том, что проверяться может любое сочетание субъект-предикат-объект. И код этого сочетания может 
совпасть с кодом одиночного триплета, имеющего значение 1. В итоге, при проверке, я выдаю, что этот триплет существует,
а на самом деле - нет. 

Переделывать шкалу - требует времени. Я пока оставлю двухбитный вариант, просто подправлю его использование.

Вроде заработала новая версия, наверное - "задышала". Испытываю на 1 млн.
Загрузка 23 сек.
Первое исполнение теста 151, 1, 280, 981
Второе - столько же.
После перезагрузки 10163, 122, 10979, 13284 - забавно...
Загрузка 18 сек. Объем базы данных 70 Мб.

Загрузил 10 млн. время 335 сек.
Времена: 1066, 617 (частичный 1_1), 2225, 12133 мс.

Снова реализую и внедряю шкалу. Сначала шкала создается динамически и проверяется ее работоспособность.
На 1 млн., 81 тыс. - разнича между числом триплетов и числом точек на шкале. Это около 20 %

Времена без шкалы: (количества результатов 51, 0, 219, 303)
68, 0, 112, 376
Со шкалой
1 - полный отказ 
9 - работа со шкалой (56 результатов)
83 - работа без шкалы (56 результатов)
1 - без фильтрации (223 результатов)
29 - без шкалы (56 результатов)


Загрузка данных в 10 млн. триплетов. Время загрузки - 144 сек., Объем данных - 688 Мб.
Времена исполнения запросов:
241, 1, 868, 4507 мс.
238, 1, 844, 4479
 

 

  


   







 