
Решил сделать "чистенький" проект по работе с "правильным" RDF. Имеется ввиду типизация полей данных.
Если я правильно понимаю стандарт RDF, значения полей данных могут быть типизированы. То есть,
объектом подобной тройки будет константа вида:
... "значение"^^<объект типа>

Если этой части константы нет, то подразумевается стандартная строка с известным типовым узлом:

"value"^^xsd:string
или 
"value"^^<http://www.w3.org/2001/XMLSchema#string>
 
Будем поддерживать: 
xsd:integer

В дальнейшем, добавим:
xsd:date
xsd:dateTime
xsd:boolean или как он там называется
xsd:number или как-то по-другому (xsd:decimal, xsd:double!) 
 
Другие типы можно будет добавлять по мере необходимости.

Теперь о языковой специализации. Если я правильно понимаю логику RDF, при его применении, фиксируется то же
значение типа, что и без указаний типа и специализатора - xsd:string.
И только в этом случае, этот специлизатор (@ru) может возникнуть. Почитаю стандарт. 

Почитал. Что-то там не сходится. Получается, что просто константная строка не сравнима с типизованной строкой,
так же как и строкой с языковым специализатором. В Turtle строка и типизованная строка идентичны. Я пойду дальше.
У меня будет храниться объединение:
RLiteral = 
	integer^integer,
	string^{s: sstring, l: sstring},
	date^longinteger,
	...

Ввод данных буду производить с помощью упрощенного парсера ttl.

Сначала отладил программу на стандартных данных. Построение базового портрета занимает на домашнем компьютере
23 мс. для 10 (стандартных) идентификаторов и это после разгона. Попробую загрузить берлинский миллион.

Загрузил. На берлинском миллионе, базовый портрет получается в первый раз за 2350 мс. Пять следующих 
портретов вычислены за 7 сек. При повторном запуске, результаты - лучше. Первый портрет - 42 мс., пять
следующих - 23 мс. База данных - 247 Мб. Загрузка данных и индексация производилась 40 сек. (15 сек. - загрузка).

Следующая задача, которую хочется решить - это гибкое управление сортировкой-выборкой. Я имею ввиду то, что
хотелось бы отсортировать индексы первично по субъекту (или объекту, соответственно) и вторично - по предикату.
Тогда можно будет производить выборки и по одному заданному субъекту и по паре субъект-предикат. Вроде ничто не
мешает. Посмотрю код.

Посмотрел, сделал. Загрузка в сортировкой по парам субъект-предикат и объект-предикат выполняется за 111 сек.
Построение портретов вроде работает. Пять портретов делаются за 25 мс. Теперь сделаю нужные процедуры.

Решил, что двойной сортировки недостаточно и теперь "главный" индекс объектных триплетов вычисляется по сортировке 
субъект-предикат-объект. Время загрузки почему-то уменьшилось. 
68 сек. загрузка.
Теперь появляются осмысленные результаты, потом надо будет их сравнить с вычисленными через Sparql.

57, 65, 213, 60, 53, 51  время=538










 